<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TANK CLASH ONLINE â€” Cross-Device PvP</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=VT323&display=swap');

  :root {
    --p1: #ff4040; --p1g: #ff8888;
    --p2: #40c8ff; --p2g: #88e0ff;
    --gold: #ffd700; --bg: #080810;
    --panel: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.1);
  }

  * { margin:0; padding:0; box-sizing:border-box; }

  body {
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'VT323', monospace;
    color: #fff;
  }

  body::before {
    content:'';
    position:fixed; inset:0;
    background-image:
      linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
    background-size: 36px 36px;
    animation: gridMove 20s linear infinite;
    pointer-events:none; z-index:0;
  }
  @keyframes gridMove { from{background-position:0 0} to{background-position:0 36px} }

  #wrapper { position:relative; z-index:1; display:flex; flex-direction:column; align-items:center; }

  /* â”€â”€â”€ HUD â”€â”€â”€ */
  #hud {
    width:700px; height:62px;
    display:flex; align-items:center;
    background:rgba(0,0,0,0.75);
    border:1px solid var(--border);
    border-bottom:none; padding:0 12px;
  }
  .phud { flex:1; padding:4px 8px; }
  .phud .pname { font-family:'Black Ops One',cursive; font-size:13px; letter-spacing:2px; margin-bottom:5px; }
  .phud.p1 .pname { color:var(--p1); text-shadow:0 0 12px var(--p1); }
  .phud.p2 .pname { color:var(--p2); text-shadow:0 0 12px var(--p2); text-align:right; }
  .hp-bar-wrap { height:10px; background:rgba(255,255,255,0.08); border-radius:5px; overflow:hidden; }
  .hp-bar { height:100%; border-radius:5px; transition:width 0.12s; }
  .p1 .hp-bar { background:linear-gradient(90deg,#c00,var(--p1),var(--p1g)); box-shadow:0 0 8px var(--p1); }
  .p2 .hp-bar { background:linear-gradient(90deg,var(--p2g),var(--p2),#007aaa); box-shadow:0 0 8px var(--p2); float:right; }
  #hud-center { width:130px; text-align:center; flex-shrink:0; }
  #score-display { font-family:'Black Ops One',cursive; font-size:26px; letter-spacing:8px; color:var(--gold); text-shadow:0 0 16px var(--gold); }
  #conn-status { font-size:11px; letter-spacing:2px; color:#444; margin-top:2px; }

  canvas { display:block; border:1px solid var(--border); box-shadow:0 0 80px rgba(0,0,0,0.95); }

  /* â”€â”€â”€ OVERLAY â”€â”€â”€ */
  #overlay {
    position:absolute; top:62px; left:0; right:0; bottom:0;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.88); z-index:10; backdrop-filter:blur(3px);
  }

  #overlay h1 {
    font-family:'Black Ops One',cursive; font-size:46px; letter-spacing:5px;
    background:linear-gradient(135deg, var(--p1), var(--gold), var(--p2));
    -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
    filter:drop-shadow(0 0 20px rgba(255,215,0,0.5));
    animation:titlePulse 2.5s ease-in-out infinite; margin-bottom:4px;
  }
  @keyframes titlePulse {
    0%,100%{filter:drop-shadow(0 0 16px rgba(255,215,0,0.4))}
    50%{filter:drop-shadow(0 0 36px rgba(255,215,0,0.9))}
  }
  .tagline { font-size:14px; letter-spacing:6px; color:#555; margin-bottom:32px; }

  /* â”€â”€â”€ LOBBY â”€â”€â”€ */
  #lobby { display:flex; flex-direction:column; align-items:center; gap:14px; width:420px; }

  .btn-row { display:flex; gap:16px; width:100%; }

  .big-btn {
    flex:1; background:transparent; cursor:pointer;
    font-family:'Black Ops One',cursive; font-size:14px; letter-spacing:3px;
    padding:16px 24px; transition:all 0.2s; position:relative; overflow:hidden;
  }
  .big-btn.gold {
    border:2px solid var(--gold); color:var(--gold);
    text-shadow:0 0 12px var(--gold);
    box-shadow:0 0 24px rgba(255,215,0,0.2), inset 0 0 20px rgba(255,215,0,0.03);
  }
  .big-btn.gold:hover { background:rgba(255,215,0,0.08); box-shadow:0 0 40px rgba(255,215,0,0.4); transform:scale(1.03); }
  .big-btn.red {
    border:2px solid var(--p1); color:var(--p1);
    text-shadow:0 0 12px var(--p1);
    box-shadow:0 0 24px rgba(255,64,64,0.2);
  }
  .big-btn.red:hover { background:rgba(255,64,64,0.08); box-shadow:0 0 40px rgba(255,64,64,0.4); transform:scale(1.03); }
  .big-btn.blue {
    border:2px solid var(--p2); color:var(--p2);
    text-shadow:0 0 12px var(--p2);
    box-shadow:0 0 24px rgba(64,200,255,0.2);
  }
  .big-btn.blue:hover { background:rgba(64,200,255,0.08); box-shadow:0 0 40px rgba(64,200,255,0.4); transform:scale(1.03); }

  /* code display box */
  .code-box {
    width:100%; background:rgba(255,215,0,0.04);
    border:1px solid rgba(255,215,0,0.2); padding:16px;
    text-align:center; display:none;
  }
  .code-label { font-size:11px; letter-spacing:4px; color:#555; margin-bottom:8px; }
  .room-code {
    font-family:'Black Ops One',cursive; font-size:38px; letter-spacing:10px;
    color:var(--gold); text-shadow:0 0 20px var(--gold);
  }
  .code-hint { font-size:12px; color:#444; letter-spacing:2px; margin-top:8px; }

  /* join input */
  .join-box { width:100%; display:none; flex-direction:column; gap:10px; }
  .join-box input {
    background:rgba(255,255,255,0.05); border:1px solid var(--border);
    color:#fff; font-family:'Black Ops One',cursive; font-size:28px;
    letter-spacing:8px; padding:12px 16px; text-align:center; outline:none;
    text-transform:uppercase; width:100%;
  }
  .join-box input:focus { border-color:var(--p2); box-shadow:0 0 20px rgba(64,200,255,0.2); }
  .join-box input::placeholder { color:#333; }

  /* status message */
  #status-msg { font-size:16px; letter-spacing:3px; color:#666; min-height:22px; text-align:center; }
  #status-msg.ok  { color:#4f4; text-shadow:0 0 12px #4f4; }
  #status-msg.err { color:var(--p1); text-shadow:0 0 12px var(--p1); }
  #status-msg.wait { color:var(--gold); text-shadow:0 0 10px var(--gold); }

  /* win screen */
  #win-msg { font-family:'Black Ops One',cursive; font-size:30px; letter-spacing:4px; margin-bottom:8px; display:none; }
  #sub-msg  { font-size:17px; color:#555; letter-spacing:4px; margin-bottom:28px; display:none; }

  /* controls hint */
  .ctrl-hint { font-size:12px; color:#2a2a40; letter-spacing:2px; text-align:center; line-height:2; margin-top:8px; }

  /* ping display */
  #ping { font-size:11px; letter-spacing:2px; color:#333; }
</style>
</head>
<body>
<div id="wrapper">
  <div id="hud">
    <div class="phud p1">
      <div class="pname" id="p1name">â–¶ PLAYER 1</div>
      <div class="hp-bar-wrap"><div class="hp-bar" id="hp1" style="width:100%"></div></div>
    </div>
    <div id="hud-center">
      <div id="score-display">0 â€” 0</div>
      <div id="conn-status">OFFLINE</div>
    </div>
    <div class="phud p2">
      <div class="pname" id="p2name">PLAYER 2 â—€</div>
      <div class="hp-bar-wrap"><div class="hp-bar" id="hp2" style="width:100%"></div></div>
    </div>
  </div>

  <canvas id="c" width="700" height="580"></canvas>

  <div id="overlay">
    <h1>TANK CLASH</h1>
    <div class="tagline">ONLINE PvP â€” CROSS DEVICE</div>

    <div id="lobby">
      <div id="win-msg"></div>
      <div id="sub-msg"></div>

      <div class="btn-row" id="main-btns">
        <button class="big-btn red" onclick="hostGame()">ðŸ”´ HOST GAME</button>
        <button class="big-btn blue" onclick="showJoin()">ðŸ”µ JOIN GAME</button>
      </div>

      <div class="code-box" id="code-box">
        <div class="code-label">SHARE THIS CODE WITH YOUR OPPONENT</div>
        <div class="room-code" id="room-code-display">â€”â€”</div>
        <div class="code-hint">Waiting for opponent to join...</div>
      </div>

      <div class="join-box" id="join-box">
        <input id="code-input" maxlength="4" placeholder="CODE" oninput="this.value=this.value.toUpperCase()" />
        <button class="big-btn blue" onclick="joinGame()">â–¶ JOIN</button>
      </div>

      <div id="status-msg"></div>
      <div class="ctrl-hint">ARROW KEYS â€” MOVE &amp; ROTATE &nbsp;|&nbsp; L or SPACE â€” FIRE</div>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TANK CLASH ONLINE â€” WebRTC P2P via public STUN
//  Uses PeerJS CDN for easy WebRTC signaling
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Dynamically load PeerJS
const peerScript = document.createElement('script');
peerScript.src = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
document.head.appendChild(peerScript);

const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// â”€â”€ Game constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAX_HP    = 100;
const MAX_WINS  = 5;
const T_SPEED   = 2.8;
const T_TURN    = 0.048;
const B_SPEED   = 7;
const B_BOUNCES = 2;
const FIRE_CD   = 30;

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let peer = null, conn = null;
let myRole = null; // 'host' | 'guest'
let gameActive = false;
let wins = [0,0];
let roomCode = '';

let tanks, bullets, particles, shockwaves, walls;
let roundTimer = 0, shakeFrames = 0;

const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Remote input state (what the other player is pressing)
let remoteKeys = {};

// â”€â”€ Peer ID â†’ Room code mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function peerIdToCode(id) {
  // Use last 4 chars of peer id, uppercase alphanumeric
  return id.replace(/[^A-Z0-9]/gi,'').slice(-4).toUpperCase();
}

// â”€â”€ Networking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function hostGame() {
  setStatus('Connecting to server...', 'wait');
  document.getElementById('main-btns').style.display = 'none';

  peerScript.onload = initHost;
  if (window.Peer) initHost();
}

function initHost() {
  peer = new Peer(undefined, {
    host: 'peerjs.com', port: 443, secure: true, path: '/'
  });

  peer.on('open', id => {
    roomCode = id;
    document.getElementById('code-box').style.display = 'block';
    document.getElementById('room-code-display').textContent = id.slice(-6).toUpperCase();
    setStatus('Waiting for opponent...', 'wait');
  });

  peer.on('connection', c => {
    conn = c;
    setupConn();
    myRole = 'host';
  });

  peer.on('error', e => {
    setStatus('Connection error: ' + e.type, 'err');
    document.getElementById('main-btns').style.display = 'flex';
  });
}

function showJoin() {
  document.getElementById('main-btns').style.display = 'none';
  document.getElementById('join-box').style.display  = 'flex';
  document.getElementById('code-input').focus();
  setStatus('Enter the host\'s code', '');
}

function joinGame() {
  const code = document.getElementById('code-input').value.trim();
  if (code.length < 4) { setStatus('Enter a valid code!', 'err'); return; }
  setStatus('Connecting...', 'wait');

  peerScript.onload = () => doJoin(code);
  if (window.Peer) doJoin(code); else peerScript.onload = () => doJoin(code);
}

function doJoin(code) {
  peer   = new Peer(undefined, { host:'peerjs.com', port:443, secure:true, path:'/' });
  myRole = 'guest';

  peer.on('open', () => {
    conn = peer.connect(code, { reliable: false, serialization: 'json' });
    setupConn();
  });

  peer.on('error', e => {
    setStatus('Could not connect â€” check the code!', 'err');
    document.getElementById('main-btns').style.display = 'flex';
    document.getElementById('join-box').style.display  = 'none';
  });
}

function setupConn() {
  conn.on('open', () => {
    setStatus('CONNECTED âœ“', 'ok');
    updateConnStatus('ONLINE');

    // Small delay then start
    setTimeout(() => {
      document.getElementById('overlay').style.display = 'none';
      startRound();
    }, 800);
  });

  conn.on('data', handleRemoteData);

  conn.on('close', () => {
    setStatus('Opponent disconnected', 'err');
    updateConnStatus('OFFLINE');
    gameActive = false;
    document.getElementById('overlay').style.display = 'flex';
  });

  conn.on('error', e => { console.warn('conn error', e); });
}

function sendData(obj) {
  if (conn && conn.open) {
    try { conn.send(obj); } catch(e) {}
  }
}

// â”€â”€ Remote data handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleRemoteData(data) {
  if (!data) return;

  if (data.type === 'keys') {
    remoteKeys = data.keys;
  }

  if (data.type === 'state' && myRole === 'guest') {
    // Host sends authoritative game state
    applyRemoteState(data);
  }

  if (data.type === 'round_end') {
    wins = data.wins;
    gameActive = false;
    updateHUD();
    showRoundEnd(data.winner);
  }

  if (data.type === 'next_round') {
    startRound();
  }
}

// â”€â”€ Game state sync (host is authoritative) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let stateTickCounter = 0;
function syncState() {
  if (myRole !== 'host' || !conn || !conn.open) return;
  stateTickCounter++;
  // Send full state every 2 frames for smoothness
  if (stateTickCounter % 2 !== 0) return;

  sendData({
    type: 'state',
    tanks: tanks.map(t => ({
      x:t.x, y:t.y, angle:t.angle, hp:t.hp, alive:t.alive,
      vx:t.vx, vy:t.vy, invuln:t.invuln
    })),
    bullets: bullets.map(b => ({x:b.x, y:b.y, vx:b.vx, vy:b.vy, owner:b.owner, color:b.color, glow:b.glow})),
    particles: particles.slice(0,60).map(p => ({x:p.x,y:p.y,color:p.color,r:p.r,life:p.life})),
    shockwaves: shockwaves.map(s => ({x:s.x,y:s.y,r:s.r,life:s.life,color:s.color})),
  });
}

function applyRemoteState(data) {
  if (!tanks) return;
  // Smoothly interpolate tank positions
  data.tanks.forEach((rt, i) => {
    if (!tanks[i]) return;
    tanks[i].x     = lerp(tanks[i].x, rt.x, 0.3);
    tanks[i].y     = lerp(tanks[i].y, rt.y, 0.3);
    tanks[i].angle = lerpAngle(tanks[i].angle, rt.angle, 0.3);
    tanks[i].hp    = rt.hp;
    tanks[i].alive = rt.alive;
    tanks[i].invuln= rt.invuln;
  });
  bullets    = data.bullets    || [];
  shockwaves = data.shockwaves || [];
}

function lerp(a, b, t)      { return a + (b - a) * t; }
function lerpAngle(a, b, t) {
  let d = b - a;
  while (d > Math.PI)  d -= Math.PI*2;
  while (d < -Math.PI) d += Math.PI*2;
  return a + d * t;
}

// â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildWalls() {
  walls = [
    {x:0,y:0,w:700,h:14}, {x:0,y:566,w:700,h:14},
    {x:0,y:0,w:14,h:580}, {x:686,y:0,w:14,h:580},
    {x:160,y:110,w:110,h:22}, {x:430,y:110,w:110,h:22},
    {x:310,y:210,w:22,h:130}, {x:110,y:280,w:150,h:22},
    {x:440,y:280,w:150,h:22}, {x:160,y:430,w:110,h:22},
    {x:430,y:430,w:110,h:22}, {x:290,y:350,w:120,h:22},
  ];
}

function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh) {
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

// â”€â”€ Tank / game init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeTank(x,y,angle,color,glow,id) {
  return {x,y,angle,color,glow,id, hp:MAX_HP, shootTimer:0,
          alive:true, vx:0,vy:0, trail:[], invuln:0};
}

function startRound() {
  buildWalls();
  bullets=[]; particles=[]; shockwaves=[];
  // P1 (host/red) left side, P2 (guest/blue) right side
  tanks = [
    makeTank(80,  290, 0,       '#ff4040','#ff8888', 0),
    makeTank(620, 290, Math.PI, '#40c8ff','#88e0ff', 1),
  ];
  roundTimer = 0;
  gameActive = true;
  updateHUD();
}

// â”€â”€ Shooting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function shoot(tank) {
  if (!tank.alive || tank.shootTimer > 0) return;
  tank.shootTimer = FIRE_CD;
  bullets.push({
    x: tank.x + Math.cos(tank.angle)*22,
    y: tank.y + Math.sin(tank.angle)*22,
    vx: Math.cos(tank.angle)*B_SPEED,
    vy: Math.sin(tank.angle)*B_SPEED,
    owner: tank.id, color: tank.color, glow: tank.glow, bounces: 0
  });
  tank.vx -= Math.cos(tank.angle)*1.5;
  tank.vy -= Math.sin(tank.angle)*1.5;
}

function bulletHitsWall(b) {
  for (const w of walls) {
    if (b.x>w.x && b.x<w.x+w.w && b.y>w.y && b.y<w.y+w.h) return w;
  }
  return null;
}

function tankInWall(t) {
  for (const w of walls) {
    if (rectsOverlap(t.x-14,t.y-12,28,24, w.x,w.y,w.w,w.h)) return w;
  }
  return null;
}

// â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x,y,color,count,speed) {
  speed=speed||4;
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2, s=Math.random()*speed+1;
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,
                    life:1,decay:Math.random()*0.03+0.015,r:Math.random()*3+1,color});
  }
}

function spawnShockwave(x,y,color) {
  shockwaves.push({x,y,r:4,maxR:60,life:1,color});
}

// â”€â”€ Update (host only runs physics) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  roundTimer++;

  // Determine which tank each player controls
  const myIdx     = myRole === 'host' ? 0 : 1;
  const remoteIdx = myRole === 'host' ? 1 : 0;
  const myTank     = tanks[myIdx];
  const remoteTank = tanks[remoteIdx];

  // My input
  const myLeft  = myRole === 'host' ? keys['KeyA']     : keys['ArrowLeft'];
  const myRight = myRole === 'host' ? keys['KeyD']     : keys['ArrowRight'];
  const myFwd   = myRole === 'host' ? keys['KeyW']     : keys['ArrowUp'];
  const myBack  = myRole === 'host' ? keys['KeyS']     : keys['ArrowDown'];
  const myFire  = myRole === 'host' ? (keys['KeyF']||keys['Space']) : (keys['KeyL']||keys['Space']);

  // Send my keys to peer
  sendData({ type:'keys', keys:{
    left: myLeft, right: myRight, fwd: myFwd, back: myBack, fire: myFire
  }});

  // Remote input
  const rLeft  = remoteKeys['left'];
  const rRight = remoteKeys['right'];
  const rFwd   = remoteKeys['fwd'];
  const rBack  = remoteKeys['back'];
  const rFire  = remoteKeys['fire'];

  // Apply to tanks (host runs full physics)
  if (myRole === 'host') {
    applyInput(myTank,     myLeft, myRight, myFwd, myBack, myFire);
    applyInput(remoteTank, rLeft,  rRight,  rFwd,  rBack,  rFire);
    updatePhysics();
    syncState();
  } else {
    // Guest: apply input locally for responsiveness, server corrects
    applyInput(myTank, myLeft, myRight, myFwd, myBack, myFire);
  }

  // Particles always run locally for smoothness
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy;
    p.vx*=0.91; p.vy*=0.91;
    p.life-=p.decay;
    if(p.life<=0) particles.splice(i,1);
  }
  for(let i=shockwaves.length-1;i>=0;i--){
    const s=shockwaves[i];
    s.r+=(s.maxR-s.r)*0.18; s.life-=0.055;
    if(s.life<=0) shockwaves.splice(i,1);
  }
}

function applyInput(t, left, right, fwd, back, fire) {
  if (!t.alive) return;
  if (left)  t.angle -= T_TURN;
  if (right) t.angle += T_TURN;
  if (fwd)   { t.vx+=Math.cos(t.angle)*0.5; t.vy+=Math.sin(t.angle)*0.5; }
  if (back)  { t.vx-=Math.cos(t.angle)*0.3; t.vy-=Math.sin(t.angle)*0.3; }
  if (fire)  shoot(t);
}

function updatePhysics() {
  // Move tanks
  for (const t of tanks) {
    if (!t.alive) continue;
    t.vx*=0.83; t.vy*=0.83;
    const spd=Math.hypot(t.vx,t.vy);
    if(spd>T_SPEED){t.vx=t.vx/spd*T_SPEED; t.vy=t.vy/spd*T_SPEED;}
    const px=t.x,py=t.y;
    t.x+=t.vx; if(tankInWall(t)){t.x=px;t.vx*=-0.3;}
    t.y+=t.vy; if(tankInWall(t)){t.y=py;t.vy*=-0.3;}
    t.trail.unshift({x:t.x,y:t.y});
    if(t.trail.length>16) t.trail.pop();
    if(t.shootTimer>0) t.shootTimer--;
    if(t.invuln>0)     t.invuln--;
  }

  // Move bullets
  for (let i=bullets.length-1;i>=0;i--) {
    const b=bullets[i];
    b.x+=b.vx; b.y+=b.vy;
    const hw=bulletHitsWall(b);
    if(hw){
      if(b.bounces>=B_BOUNCES){spawnParticles(b.x,b.y,b.color,6,2);bullets.splice(i,1);continue;}
      b.bounces++;
      const dx=(b.x-(hw.x+hw.w/2))/hw.w, dy=(b.y-(hw.y+hw.h/2))/hw.h;
      if(Math.abs(dx)>Math.abs(dy)) b.vx*=-1; else b.vy*=-1;
      spawnParticles(b.x,b.y,b.color,5,2);
      continue;
    }
    let hit=false;
    for(const t of tanks){
      if(!t.alive||b.owner===t.id||t.invuln>0) continue;
      if(Math.hypot(b.x-t.x,b.y-t.y)<18){
        t.hp-=20; t.invuln=14;
        spawnParticles(b.x,b.y,t.color,20,5);
        spawnShockwave(b.x,b.y,t.color);
        shakeFrames=9;
        bullets.splice(i,1); hit=true;
        if(t.hp<=0){t.hp=0;t.alive=false;killTank(t);}
        updateHUD();
        break;
      }
    }
    if(!hit&&(b.x<0||b.x>W||b.y<0||b.y>H)) bullets.splice(i,1);
  }
}

function killTank(t) {
  spawnParticles(t.x,t.y,t.color,45,7);
  spawnShockwave(t.x,t.y,t.color);
  const winner = t.id===0?1:0;
  wins[winner]++;
  gameActive = false;
  updateHUD();

  if (myRole === 'host') {
    sendData({ type:'round_end', winner, wins });
    setTimeout(() => showRoundEnd(winner), 950);
  }
}

function showRoundEnd(winner) {
  const isChamp = wins[winner] >= MAX_WINS;
  const names   = ['PLAYER 1','PLAYER 2'];
  const colors  = ['#ff4040','#40c8ff'];
  const winMsg  = document.getElementById('win-msg');
  const subMsg  = document.getElementById('sub-msg');
  const overlay = document.getElementById('overlay');

  winMsg.style.display = 'block';
  subMsg.style.display = 'block';
  winMsg.style.color = colors[winner];
  winMsg.style.textShadow = `0 0 28px ${colors[winner]}`;
  winMsg.textContent = isChamp ? `ðŸ† ${names[winner]} WINS!` : `${names[winner]} TAKES THE ROUND`;
  subMsg.textContent = isChamp ? 'CHAMPION OF THE ARENA' : `SCORE:  ${wins[0]} â€” ${wins[1]}`;

  if (isChamp) wins=[0,0];

  // Show a "next round" button (host triggers)
  const btn = document.createElement('button');
  btn.className = 'big-btn gold';
  btn.style.marginTop = '4px';
  btn.textContent = isChamp ? 'âš” NEW GAME' : 'â–¶ NEXT ROUND';
  btn.onclick = () => {
    btn.remove();
    winMsg.style.display='none';
    subMsg.style.display='none';
    overlay.style.display='none';
    if (myRole==='host') {
      sendData({type:'next_round'});
    }
    startRound();
  };

  // Only host can click it; guest auto-starts on recv
  if (myRole === 'guest') {
    btn.style.opacity = '0.4';
    btn.style.pointerEvents = 'none';
    btn.textContent += ' (waiting for host)';
  }

  document.getElementById('lobby').appendChild(btn);
  overlay.style.display = 'flex';
}

function updateHUD() {
  if(!tanks) return;
  document.getElementById('hp1').style.width=Math.max(0,tanks[0].hp)+'%';
  document.getElementById('hp2').style.width=Math.max(0,tanks[1].hp)+'%';
  document.getElementById('score-display').textContent=`${wins[0]} â€” ${wins[1]}`;
  // Label by role
  if(myRole==='host'){
    document.getElementById('p1name').textContent='â–¶ YOU';
    document.getElementById('p2name').textContent='OPPONENT â—€';
  } else {
    document.getElementById('p1name').textContent='â–¶ OPPONENT';
    document.getElementById('p2name').textContent='YOU â—€';
  }
}

function updateConnStatus(s) {
  const el=document.getElementById('conn-status');
  el.textContent=s;
  el.style.color=s==='ONLINE'?'#4f4':'#f44';
}

function setStatus(msg,type) {
  const el=document.getElementById('status-msg');
  el.textContent=msg;
  el.className=type||'';
}

// â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawArena() {
  ctx.fillStyle='#0c0c18'; ctx.fillRect(0,0,W,H);
  ctx.save(); ctx.globalAlpha=0.025; ctx.strokeStyle='#fff'; ctx.lineWidth=0.5;
  const hs=30;
  for(let row=0;row*hs*1.5<H+hs*2;row++)
    for(let col=0;col*hs*1.73<W+hs*2;col++){
      const cx=col*hs*1.73+(row%2)*hs*0.865, cy=row*hs*1.5;
      ctx.beginPath();
      for(let k=0;k<6;k++){
        const a=(Math.PI/3)*k-Math.PI/6;
        k===0?ctx.moveTo(cx+hs*Math.cos(a),cy+hs*Math.sin(a))
             :ctx.lineTo(cx+hs*Math.cos(a),cy+hs*Math.sin(a));
      }
      ctx.closePath(); ctx.stroke();
    }
  ctx.restore();
}

function drawWalls() {
  for(const w of walls){
    const g=ctx.createLinearGradient(w.x,w.y,w.x,w.y+w.h);
    g.addColorStop(0,'#22223a'); g.addColorStop(1,'#111120');
    ctx.fillStyle=g; ctx.fillRect(w.x,w.y,w.w,w.h);
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
    ctx.strokeRect(w.x+.5,w.y+.5,w.w-1,w.h-1);
    ctx.fillStyle='rgba(255,255,255,0.04)';
    ctx.fillRect(w.x+1,w.y+1,w.w-2,Math.min(5,w.h-2));
  }
}

function drawTank(t) {
  ctx.save();
  for(let i=t.trail.length-1;i>=0;i--){
    const alpha=(1-i/t.trail.length)*0.14;
    ctx.beginPath();
    ctx.arc(t.trail[i].x,t.trail[i].y,11*(1-i/t.trail.length),0,Math.PI*2);
    ctx.fillStyle=t.color+Math.floor(alpha*255).toString(16).padStart(2,'0');
    ctx.fill();
  }
  if(t.invuln>0&&Math.floor(roundTimer/3)%2===0){ctx.restore();return;}
  ctx.translate(t.x,t.y); ctx.rotate(t.angle);
  ctx.shadowColor=t.color; ctx.shadowBlur=20;
  ctx.fillStyle=t.color; ctx.beginPath(); ctx.roundRect(-15,-12,30,24,4); ctx.fill();
  ctx.shadowBlur=0;
  ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.roundRect(-15,-12,30,24,4); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.roundRect(-13,-10,26,10,3); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(-5,-12); ctx.lineTo(-5,12); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(5,-12); ctx.lineTo(5,12); ctx.stroke();
  ctx.shadowColor=t.glow; ctx.shadowBlur=12;
  ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.beginPath(); ctx.arc(-2,-2,5,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=t.glow; ctx.shadowBlur=10; ctx.fillRect(7,-3.5,20,7);
  ctx.fillStyle='#fff'; ctx.shadowBlur=18; ctx.fillRect(25,-2.5,4,5);
  ctx.shadowBlur=0; ctx.fillStyle='rgba(0,0,0,0.65)';
  [-8,0,8].forEach(x=>{ctx.fillRect(x-3.5,-16,7,5);ctx.fillRect(x-3.5,11,7,5);});
  ctx.fillStyle='rgba(255,255,255,0.08)';
  [-8,0,8].forEach(x=>{ctx.fillRect(x-3,-15.5,6,2);ctx.fillRect(x-3,11.5,6,2);});
  ctx.restore();

  // "YOU" label above your tank
  const myIdx = myRole==='host'?0:1;
  if(t.id===myIdx){
    ctx.save();
    ctx.font='bold 11px VT323,monospace';
    ctx.fillStyle=t.glow; ctx.textAlign='center';
    ctx.shadowColor=t.glow; ctx.shadowBlur=8;
    ctx.fillText('YOU',t.x,t.y-34);
    ctx.restore();
  }
}

function drawBullets() {
  for(const b of bullets){
    ctx.save();
    const g=ctx.createLinearGradient(b.x-b.vx*6,b.y-b.vy*6,b.x,b.y);
    g.addColorStop(0,'transparent'); g.addColorStop(1,b.color+'cc');
    ctx.strokeStyle=g; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.moveTo(b.x-b.vx*6,b.y-b.vy*6); ctx.lineTo(b.x,b.y); ctx.stroke();
    ctx.shadowColor=b.glow; ctx.shadowBlur=16;
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(b.x,b.y,4.5,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawParticles() {
  for(const p of particles){
    ctx.save(); ctx.globalAlpha=p.life;
    ctx.shadowColor=p.color; ctx.shadowBlur=9; ctx.fillStyle=p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawShockwaves() {
  for(const s of shockwaves){
    ctx.save(); ctx.globalAlpha=s.life*0.7;
    ctx.strokeStyle=s.color; ctx.shadowColor=s.color; ctx.shadowBlur=14; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=s.life*0.12; ctx.fillStyle=s.color; ctx.fill();
    ctx.restore();
  }
}

function drawHP() {
  if(!tanks) return;
  for(const t of tanks){
    if(!t.alive) continue;
    const bw=44,bh=6,bx=t.x-bw/2,by=t.y-30;
    ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(bx-1,by-1,bw+2,bh+2);
    const pct=t.hp/MAX_HP;
    const bc=pct>0.5?t.color:pct>0.25?'#ffaa00':'#ff2020';
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(bx,by,bw,bh);
    ctx.fillStyle=bc; ctx.shadowColor=bc; ctx.shadowBlur=8;
    ctx.fillRect(bx,by,bw*pct,bh); ctx.shadowBlur=0;
  }
}

function drawIdleScreen() {
  ctx.fillStyle='#0c0c18'; ctx.fillRect(0,0,W,H);
  ctx.save(); ctx.globalAlpha=0.02; ctx.strokeStyle='#fff'; ctx.lineWidth=0.5;
  const hs=30;
  for(let row=0;row*hs*1.5<H+hs*2;row++)
    for(let col=0;col*hs*1.73<W+hs*2;col++){
      const cx=col*hs*1.73+(row%2)*hs*0.865,cy=row*hs*1.5;
      ctx.beginPath();
      for(let k=0;k<6;k++){const a=(Math.PI/3)*k-Math.PI/6;k===0?ctx.moveTo(cx+hs*Math.cos(a),cy+hs*Math.sin(a)):ctx.lineTo(cx+hs*Math.cos(a),cy+hs*Math.sin(a));}
      ctx.closePath(); ctx.stroke();
    }
  ctx.restore();
}

// â”€â”€ Game Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  if (gameActive && tanks) {
    update();
    ctx.save();
    if(shakeFrames>0){
      ctx.translate((Math.random()-.5)*shakeFrames*.9,(Math.random()-.5)*shakeFrames*.9);
      shakeFrames--;
    }
    drawArena(); drawShockwaves(); drawWalls();
    drawParticles(); drawBullets();
    for(const t of tanks){if(t.alive)drawTank(t);}
    drawHP();
    ctx.restore();
  } else {
    drawIdleScreen();
    // animate a demo tank on menu
    if(!tanks) {
      buildWalls();
      tanks=[makeTank(80,290,0,'#ff4040','#ff8888',0),makeTank(620,290,Math.PI,'#40c8ff','#88e0ff',1)];
      bullets=[]; particles=[]; shockwaves=[];
    }
    drawWalls();
    for(const t of tanks){drawTank(t);}
  }
  requestAnimationFrame(loop);
}

// Round timer counter for idle animation
setInterval(()=>{if(!gameActive)roundTimer++;},16);

loop();
</script>
</body>
</html>
